.. |version| replace:: 1.0.2

ATA SNAP F-Engine Firmware User Manual
======================================
..
  As part of the Allen Telescope Array (ATA) refurbishment project, the digitization and channelization hardware used at the ATA has been upgraded to use the Xilinx Kintex 7 ``SNAP'' platform. Each SNAP board provides more processing power than the iBoB platform it replaces, and potentially allows wider bandwidth processing. This document describes the functionality of the SNAP F-Engine hardware and firmware, including its user interface and run-time parameters.


Introduction
------------
This repository contains firmware and software for a SNAP-based F-Engine (i.e. channelizer) system for the Allen Telescope Array (ATA).

The system digitizes RF signals from the ATA at a speed, :math:`f_s`, of up to 2500 Msps and generates 4096 frequency channels over the Nyquist band.
Two operational modes are supported: *Spectrometer* mode, and *Voltage* mode. These different modes, shown in a high-level block diagram in :numref:`fig-ata-snap-feng-overview`, apply different processing to the channelizer output prior to outputing data over 10 gigabit Ethernet (10GbE).

.. figure:: _static/figs/ata-snap-feng-overview.png
    :align: center
    :name: fig-ata-snap-feng-overview
    
    The ATA SNAP F-Engine firmware comprises two pipelines. One of these -- the *Spectrometer* pipeline -- generates accumulated power spectra. The other -- the *Voltage Pipeline* -- generates a complex voltage stream channelized into 2048 frequency bins.


Spectrometer Mode
~~~~~~~~~~~~~~~~~

In *Spectrometer* mode, integrated power spectra are generated by the SNAP Firmware.
The resolution of these spectra, :math:`f_c`, is :math:`\frac{f_s}{8192}`.
At maximum sampling rate, :math:`f_s = 2500` Msps, resulting in a spectra resolution :math:`f_c = 305` kHz.

Spectra are generated for both the X- and Y-polarizations, which are formatted as an :math:`f_c`-element array of 32-bit signed integers.
A cross-power spectra, defined as the multiple of an X-polarization spectra with the complex conjugate of a Y-polarization spectra, is also computed.
This is formatted as an :math:`f_c`-element array of 32-bit complex (i.e. 32-bit real, 32-bit imaginary) signed integers.

Data are accumulated for a runtime-configurable number of spectra, and are output from the firmware as a UDP data stream over a 10 Gb Ethernet link.
The output format is described in detail in :ref:`sec-data-format`.

Voltage Mode
~~~~~~~~~~~~

In *Voltage* mode, up to 2048 frequency channels - each with a resolution of :math:`\frac{f_s}{8192}` - are output over a 10 Gb Ethernet link.

In this mode, data are transmitted as complex, signed, 4-bit integers over a UDP data stream.

This Document
~~~~~~~~~~~~~

This document describes the hardware configuration required by the F-Engine system, the runtime configuration proceedures, and the software control functionality made available to the user.
It also provides a description of the output data formats of each of the two data processing modes.

.. _sec-data-format:

Output Data Formats
-------------------

.. _sec-spec-format:

Spectrometer Packets
~~~~~~~~~~~~~~~~~~~~

In versions 1.0.x  of the SNAP firmware, each spectrometer dump is a 64 kiB data set, comprising 4096 channels and 4 32-bit words per channel.
Each data dump is transmitted from the SNAP in 8 UDP packets, each with an 512 channel (8 kiB) payload and 8 byte header:

.. code-block:: C

  #define N_c 512
  #define N_p 4

  struct spectrometer_packet {
    uint64 header;
    int32 data[N_c, N_p]
  };

The header should be read as a network-endian 64-bit unsigned integer, with the following bit fields:
  - bits[7:0] (i.e. ``header & 0xff``) : 8-bit antenna ID
  - bits[10:8] (i.e. ``(header >> 8) & 0x7``) : 3-bit channel block index
  - bits[55:11] (i.e. ``(header >> 11) & 0x1fffffffffff``) : 45-bit accumulation ID
  - bits[63:56] (i.e. ``(header >> 56) & 0xff``) : 8-bit firmware version

Headers fields should be interpretted as follows:
  - *Antenna ID*: A runtime configurable ID which uniquely associates a packet with a particular SNAP board and antenna. See ``TODO``
  - *Channel block index*: Indicates which channels are in this packet. A value of :math:`b` indicates that this packet contains channels :math:`512b` to :math:`512(b+1)`.
  - *Accumulation ID*: A counter that represents the integration number. I.e., the first integration will have an ID 0, the second and ID 1, etc. These IDs should be referred to GPS time through knowledge of the system sampling rate and accumulation length parameters, and the system was last synchronized (see ``TODO``).
  - *Firmware version*: Bit [7] is always 0 for *Spectrometer* packets. The remaining bits contain a compile-time defined firmware version, represented in the form bit[6].bits[5:3].bits[2:0]. This document refers to firmware version |version|.

The data payload in each packet should be interpretted as an 8192 byte array of network-endian 32-bit integers with dimensions ``channel x polarization-product``.
The ``channel`` index runs from 0 to 511.
The ``polarization-product`` index runs from 0-3 with:

  - index 0: :math:`XX` product
  - index 1: :math:`YY` product
  - index 2: *real* part of :math:`XY^*` product 
  - index 3: *imag* part of :math:`XY^*` product 

Voltage Packets
~~~~~~~~~~~~~~~

The *Voltage* mode of the SNAP firmware outputs a continuous stream of voltage data, encapsulated in UDP packets.
Each packet contains a data payload of 8192 bytes, made up of 16 time samples for 256 frequency channels of dual-polarization data:

.. code-block:: C

  #define N_t 16
  #define N_c 256
  #define N_p 2

  struct spectrometer_packet {
    uint64 header;
    int32 data[N_t, N_c, N_p]
  };

The header should be read as a network-endian 64-bit unsigned integer, with the following bit fields:
  - bits[5:0] (i.e. ``header & 0x3f``) : 6-bit antenna ID
  - bits[17:6] (i.e. ``(header >> 6) & 0xfff``) : 12-bit channel number
  - bits[55:18] (i.e. ``(header >> 18) & 0x3fffffffff``) : 38-bit sample number
  - bits[63:56] (i.e. ``(header >> 56) & 0xff``) : 8-bit Firmware version

Headers fields should be interpretted as follows:
  - *Antenna ID*: A runtime configurable ID which uniquely associates a packet with a particular SNAP board and antenna. See ``TODO``
  - *Channel number*: The index of the first channel present in this packet. For example, a channel number :math:`c` implies the packet contains channels :math:`c` to :math:`c+255`.
  - *Sample number*: The index of the first time sample present in this packet. For example, a sample number :math:`s` implies the packet contains samples :math:`s` to :math:`s+15`. Sample number can be referred to GPS time through knowledge of the system sampling rate and accumulation length parameters, and the system was last synchronized (see ``TODO``).
  - *Firmware version*: Bit [7] is always 1 for *Voltage* packets. The remaining bits contain a compile-time defined firmware version, represented in the form bit[6].bits[5:3].bits[2:0]. This document refers to firmware version |version|.

Note that at full sample rate (2500 Msps) spectra are generated every 3.2 microseconds, thus a 38-bit spectra counter will roll over every ~10 days.
Downstream software should take account of this if the system is expected to run for longer than this duration without a new synchronization trigger (see ``TODO``)

The data payload in each packet is 8192 bytes. Each bytes of data should be interpretted as a 4-bit complex number (i.e. 4-bit real, 4-bit imaginary) with the most significant 4 bits of each byte representing the real part of the complex sample, and the least significant 4 bits representing the imaginary part of the complex sample.

The complete payload is an array with dimensions ``time x channel x polarization``, with

  - ``time`` index running from 0 to 15
  - ``channel`` index running from 0 to 255
  - ``polarization`` index running from 0 to 1 with index 0 representing the X-polarization, and index 1 the Y-polarization.


Hardware Overview
-----------------

A pair of analog inputs to the SNAP system are digitized with a CASPER-designed *ADC5g* ADC card [casper_adc5g]_ which hosts a single e2v EV8AQ160 chip [e2v]_.
The EV8AQ160 is a cost-effective 8-bit, quad-channel, 1250 Msps ADC, which can be configured to run as a dual-channel 2500 Msps, or single-channel 5000 Msps digitizer. The ATA system uses dual-channel configuration, with each ADC5g card processing dual polarization inputs from a single dish.

Digital signal processing is performed using a CASPER-designed SNAP board [casper_snap]_.
The SNAP is a simple FPGA-based processor, featuring a low-cost Kintex 7 FPGA, and a pair of SFP+ connectors each capable of supporting a 10~Gb Ethernet link.
In addition to the FPGA, the SNAP hosts three on-board Hittite HMCAD1511 ADC chips [hmcad1511]_, which are not used in the ATA deployment owing to their relatively low sampling rate.

SNAPs and their ADCs are housed in a custom-designed 1U enclosure, shown in :numref:`fig-snap-box-front` and :numref:`fig-snap-box-internal`.
This box also houses a Raspberry Pi 2 Model B [rpi]_ which provides the ability to remotely program and interact with a SNAP board.

.. figure:: _static/figs/snap-box-front.png
    :align: center
    :name: fig-snap-box-front

    The custom-designed 1U SNAP enclosure front panel. Interfaces (left to right): A pair of 10GbE-capable SFP+ ports; SMA input for a trigger signal; SMA output for a trigger signal; SMA input for onboard-ADC reference clock (not used at the ATA); SMA inputs for onboard-ADC sample clock (not used at the ATA); SMA inputs for 12 on-board ADC channels (not used at the ATA); four SMA inputs routed to the ADC5G card -- dual RF inputs, a sampling clock, and a trigger signal; RJ45 1GbE interface routed to an internal Raspberry Pi single-board computer; 110-230V AC power.

.. figure:: _static/figs/snap-box-internal.png
    :align: center
    :name: fig-snap-box-internal

    Internal wiring of the ATA SNAP enclosure. Not shown is a Raspberry Pi control computer, whose mount holes are visible to the upper-right of the SNAP board. RF anti-aliasing filters are visible on the ADC analog RF inputs. These may be removed if upstream filtering is present in the system.

The complete ATA system, comprising multiple boards, should be driven by a common sampling clock, at a maximum rate of 2500~Msps. Each board should also be fed with a time-aligned trigger signal, which is used to synchronize the the capture of data by different boards in the system.


Firmware Overview
-----------------

The firmware described in this document is designed in Mathwork's Simulink using CASPERs FPGA programming libraries.
The Simulink source file is available `on github <https://github.com/realtimeradio/ata_snap/blob/master/snap_adc5g_feng_rpi.slx>`_.

Building the Simulink Model
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The SNAP firmware model (``snap_adc5g_feng_rpi.slx``)  was built with the following software stack.
Use other versions at your peril.

  - Ubuntu 18.04 64-bit
  - MATLAB/Simulink 2019a, including Fixed Point Designer Toolbox
  - Xilinx Vivado System Edition 2019.1.3
  - ``mlib_devel`` (version controlled within the ``ata_snap`` repository.

To obtain and open the Simulink model:

.. code-block:: console

  # Clone the firmware repository
  git clone https://github.com/realtimeradio/ata_snap

  # Clone relevant sub-repositories
  cd ata_snap
  git submodule init
  git submodule update

  # Install the mlib_devel dependencies
  # You may want to install these in a Python virtual environment
  cd mlib_devel
  pip install -r requirements.txt

Next, create a local environment specification file in the ``ata_snap`` directory, named ``startsg.local``.
An example environment file is:

.. code-block:: console

  #!/bin/bash
  ####### User to edit these accordingly ######
  export XILINX_PATH=/data/Xilinx/Vivado/2019.1
  export MATLAB_PATH=/data/MATLAB/R2019a
  # PLATFORM lin64 means 64-bit Linux
  export PLATFORM=lin64
  # Location of your Xilinx license
  export XILINXD_LICENSE_FILE=/home/jackh/.Xilinx/Xilinx.lic
  
  # Library tweaks
  export LD_PRELOAD=${LD_PRELOAD}:"/usr/lib/x86_64-linux-gnu/libexpat.so"
  # An optional python virtual environment to activate on start
  export CASPER_PYTHON_VENV_ON_START=/home/jackh/casper-python3-venv

You should edit the paths accordingly.

To open the firmware model, from the top-level of the repository (i.e. the ``ata_snap`` directory) run ``./startsg``.
This will open MATLAB with appropriate libraries, at which point you can open the ``snap_adc5g_feng_rpi.slx`` Simulink model.
  
Firmware Overview
~~~~~~~~~~~~~~~~~

The Simulink source code for the SNAP firmware is shown in :numref:`fig-simulink-diagram-labeled`.
A pictorial representation with annotated data path bit widths is shown in :numref:`fig-ata-snap-feng`.

.. figure:: _static/figs/simulink-diagram-labeled.png
    :align: center
    :name: fig-simulink-diagram-labeled
    
    The ``snap_adc5g_feng_rpi.slx`` Simulink design, with annotations.

.. figure:: _static/figs/ata-snap-feng.png
    :align: center
    :name: fig-ata-snap-feng
    
    A pictorial representation of the SNAP firmware, showing major processing modules and the bit widths of their data paths. Yellow circles in this diagram represent the runtime-controllable elements of the pipeline.

In the remainder of this section an overview of the functional modules in the system is given.

Module Descriptions
~~~~~~~~~~~~~~~~~~~

Here basic explanations of the functionality of the different firmware processing modules is given.
Where modules can be controlled or monitored at runtime, software routines to do so are described in :ref:`sec-runtime-control`.

ADC
^^^

The ADC module encapsulates an interface to an e2v EV8AQ160 [e2v]_ ADC chip.
This chip has four independent ADC cores which can each run at up to 1250 Msps.
In the ATA firmware, these are configured as a pair of 2500 Msps samplers.

On power-up, and after reprogramming the FPGA, the ADC interface must be initialized.
Initialization ensures that the ADC is in the correct operating mode, and that the ADC and FPGA link is appropriately trained.
Training ensures that the digital data transmitted from the ADC is successfully received by the FPGA, and involves tweaking the FPGA-side capture clock phase for reliable data reception.

To ensure that the ADCs are correctly configured when programming the SNAP boards, the boards should always be loaded with firmware using the ``program`` method (see :ref:`sec-runtime-control`).

TODO: Add software method and instructions for inter-core mismatch calibration.

Relevant Software Methods
`````````````````````````

  - ``program``: Load new firmware onto a SNAP and intialize the ADCs
  - ``adc_initialize``: Perform a standalone initialization of the ADCs
  - ``adc_get_samples``: Get a snapshot of raw ADC samples
  - ``adc_get_stats``: Get the mean, mean power, and number of clipping events from the last 512k samples

Filter Bank
^^^^^^^^^^^

The Filter Bank (aka Polyphase Filter Bank, PFB [pfb]_) separates the X- and Y-polarization input broad-band data streams into 4096 frequency channels, starting at DC, with centers separated by :math:`\frac{f_s}{4096}`.
These baseband frequencies, from DC to :math:`\frac{f_s}{2}` represent different sky-frequencies when the input analog signals are mixed with LOs upstream of the digital system.

As shown in :numref:`fig-ata-snap-feng`, the PFB receives real-valued broad-band data with 8-bits resolution, and after processing delivers complex-valued spectra with 18-bit resolution.

Internally, the FFT processes data at a precision of 25 bits, allowing for signifcant growth in the required dynamic range of the narrow-band signals.
The internal data path is shown, with relevant data bit width, in :numref:`fig-pfb-bitwidth`.

.. figure:: _static/figs/pfb-bitwidth.png
    :align: center
    :name: fig-pfb-bitwidth
    
    A pictorial representation of the PFB internal datapath, showing internal data precision. Coefficients in the FIR and FFT modules are stored with 18 bits resolution. Overall signal amplitude growth is controlled with a runtime-applied *shift schedule*, and monitoring allows for overflows at two stages of the PFB pipeline to be detected.

Critical for effective operation of the PFB is the application of an appropriate FFT *shift schedule*.
The shift schedule controls, for each butterfly stage of the FFT, whether data are allowed to grow, or should be divided by two to prevent overflows.
In general, an FFT with :math:`2^N` points has :math:`N` butterfly stages, and dynamic range should grow by :math:`N` bits to guarantee against overflow.
Allowing such large bitgrowth is resource-intensive, so scaling down data to prevent overflow can be a useful alternative.

The SNAP firmware processes 18-bit inputs with 25-bits of precision, allowing for 7 bits of growth.
A further scaling down of :math:`2^6` using the shift schedule is sufficient to guarantee against overflow.
It is therefore recommended that the shift schedule is set to scale by at least this much.

After the FFT, the data path is scaled back to 18 bits to facilitate cheaper downstream processing.
This scaling is implemented by saturating the input signal if it exceeds the range permitted by an 18-bit representation.

Software routines are provided to count the number of overflows both within the FFT module, and in the post-FFT saturation logic.

Note that saturation events in the FFT should be absolutely avoided (and preferably the shift schedule should be chosen so as to make them impossible) since these corrupt entire FFT frames.
Saturation events in the downstream casting of data from 25 to 18 bits corrupt only the channel which has saturated.
In most cases, this is likely to be RFI.

The suggested configuration of the PFB is therefore as follows:

  #. Set the FFT shift schedule to scale by :math:`2^6` (see ``fft_set_shift``).
  #. Over a long period of integration, verify that no overflows within the FFT are occuring (see ``fft_of_detect``).
  #. Check for overflows in the downstream data-saturation logic (see ``fft_cast_of_detect``).
  #. Check power spectra to verify that power-levels are not saturating anywhere near the level of signals-of-interest (see ``spec_read``)

Relevant Software Methods
`````````````````````````

  - ``fft_set_shift``: Set the FFT shift schedule
  - ``fft_of_detect``: Count overflows in the FFT module
  - ``fft_cast_of_detect``: Count overflows downstream of the FFT
  - ``spec_read``: Read an accumulated spectrum
  - ``spec_plot``: Plot an accumulated spectrum

Spectral Power Accumulator
~~~~~~~~~~~~~~~~~~~~~~~~~~

The Spectral Power Accumulator generates power-spectra for the two input data streams.

First, the auto- and cross- power of the two input data streams are computed.
The former are real-valued, while the latter is complex.

All are computed by:

  #. Multiplying 18-bit voltage inputs to generate 36-bit powers
  #. Rounding (to even) these 36-bit powers to 25 bits, throwing away the least-significant bits
  #. Integrating these powers into 32-bit accumulators, with a runtime-configurable integration length

The nature of the bit handling in this implementation has the following "features":

  #. Discarding the least-significant bits of the signal powers prior to accumulation potentially makes the system vulnerable to degraded performance if the inputs are very low-power. Avoiding excessive downshifting in the PFB can minimize the impact of this effect. Verifying that data output from the accumulators is consistent with reasonable input signal levels (i.e. after dividing out the accumulation length, the resulting value should be :math:`>>1`) can verify this is not a problem.
  #. The accumulators can only guarantee that 128 spectra can be integrated without overflow. This is only ~400 microseconds of data!

In practice, neither of these issues is likely to cause problems, except in the case of very long (>>1 second) integrations.

Spectra can be read from the power accumulator via software -- appropriate for monitoring, debugging, and low time-resolution (~1s) observations -- or can be streamed out of the SNAP's 10 GbE interface.
The latter interface supports integration lengths of down to 150 micro-seconds, and emits data in the format descibed in :ref:`sec-spec-format`.

A test vector injection module exists for the purposes of testing the spectrometer pipeline.
When activated, this module replaces PFB data with a test pattern whose real parts are zero, and whose imaginary parts form a counter.
For the X-polariaztion, FFT channel :math:`i` takes the value :math:`32*(8 floor(\frac{i}{4}) + mod(i, 4))`.
For the Y-polariaztion, FFT channel :math:`i` takes the value :math:`32*(8 floor(\frac{i}{4}) + mod(i, 4)) + 4`.

Scaling in the spectrometer is such that the test vector inputs appear at the accumulator input with FFT channel :math:`i` having the values:

  - For the X-polarization: :math:`8*floor(\frac{i}{4}) + mod(i, 4)`.
  - For the Y-polarization: :math:`8*floor(\frac{i}{4}) + mod(i, 4) + 4`.

This pattern can be checked against observed output data to verify that the two polarizations are being correctly identified, and accumulation length is being correctly set.

Relevant Software Methods
`````````````````````````
  - ``set_accumulation_length``: Set the number of spectra to be accumulated
  - ``spec_read``: Read an accumulated spectrum
  - ``spec_plot``: Plot an accumulated spectrum
  - ``eth_set_mode``: Choose between spectrometer and voltage 10GbE outputs
  - ``eth_set_dest_port``: Set the destination UDP port for 10GbE traffic
  - ``spec_set_destination``: Set the destination IP address for spectrometer packets
  - ``spec_test_vector_mode``: Turn on and off the spectrometer test-vector mode

Equalization
~~~~~~~~~~~~

In the voltage pipeline, post-PFB data are quantized to 4 bits prior to being transmitted over 10 GbE.

Reducing data to such low bit-precision requires carefully managing input signal levels.
As such, prior to equalization, spectra are multiplied by a runtime-programmable amplitude scaling factor.
The scaling factors can be uniquely specified per polarization and per frequency channel, and should be used to ensure that data in each frequency channel exhibit an appropriate RMS.

Equalization coefficients can be computed by inferring the power levels out of the PFB using the SNAP's inbuilt spectrometer, and computing the necessary scaling required to target an optimal level [quant]_.

Otherwise, coefficients may be computed by a downstream receiver which has direct access to the 4-bit levels.

TODO: Provide a method to do this, given the scalings, it's non trivial.

Relevant Software Methods
`````````````````````````

  - ``eq_load_coeffs``: Load a set of equalization coefficients
  - TODO: Add method to auto-set.

Voltage Channel Selection
~~~~~~~~~~~~~~~~~~~~~~~~~

Relevant Software Methods
`````````````````````````

  - ``select_output_channels``: Select which frequency channels are to be sent over 10 GbE
  - ``eq_load_test_vectors``: Load a custom set of test vectors into the voltage data path
  - ``eq_test_vector_mode``: Turn on or off voltage test vector injection

10Gb Ethernet
~~~~~~~~~~~~~~~~~~~~~~~~~~

Relevant Software Methods
`````````````````````````

  - ``eth_reset``: Reset the Ethernet core
  - ``eth_set_mode``: Choose between spectrometer and voltage 10GbE outputs
  - ``eth_set_dest_port``: Set the destination UDP port for 10GbE traffic
  - ``eth_enable_output``: Turn on 10GbE transmission
  - ``eth_print_counters``: Print Ethernet packet statistics

Spectral Power Accumulator
~~~~~~~~~~~~~~~~~~~~~~~~~~

Relevant Software Methods
`````````````````````````
.. _sec-runtime-control:

Run-time Control
----------------

Installing the Control Library
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The *ata_snap* python library is provided to control the F-Engine firmware design. It requires Python >=3.5 and the following custom python libraries:

#. casperfpga (a control library for interacting with CASPER hardware, such as SNAP boards)
#. adc5g (a library for configuring the ADC5G card)

These libraries are bundled in the *ata_snap* repository to minimize issues with library version compatibility.

To install the control libraries:

.. code-block:: console

  # Clone the ata_snap repository
  git clone https://github.com/realtimeradio/ata_snap

  # Clone relevant sub-repositories
  cd ata_snap
  git submodule init
  git submodule update

  # Install casperfpga
  cd sw/casperfpga
  # Install casperfpga dependencies (requires pip, which can be installed with `apt install python3-pip`
  pip install -r requirements.txt
  # Install casperfpga
  python setup.py install

  # Install the adc5g library
  cd ../adc5g/adc5g
  python setup.py install

  # Install the ata_snap library
  cd ../../../ata_snap
  python setup.py install

If the library has installed correctly, in a Python shell, you should be able to successfully execute

.. code-block:: python

  from ata_snap import ata_snap_fengine

Configuration Recipes
---------------------

Simple use of the *ata_snap* library comprises the following steps:

#. Program the SNAP boards with appropriate firmware
#. Configure any runtime settings
#. Synchronize SNAP boards with UTC
#. Turn on data flow

Once these steps are complete, data will be transmitted over Ethernet and downstream software can catch and process this data as desired.

For a single SNAP board, all of these steps can be carried out at once using a provided intialization scrips ``snap_feng_init.py``.
This script has the following use template:

.. code-block:: console

  $ snap_feng_init.py -h
  usage: snap_feng_init.py [-h] [-s] [-t] [--eth_spec] [--eth_volt] [-a ACCLEN]
                           [-f FFTSHIFT] [--specdest SPECDEST]
                           host fpgfile configfile
  
  Program and initialize a SNAP ADC5G spectrometer
  
  positional arguments:
    host                 Hostname / IP of SNAP
    fpgfile              .fpgfile to program
    configfile           Configuration file
  
  optional arguments:
    -h, --help           show this help message and exit
    -s                   Use this flag to re-arm the design's sync logic
                         (default: False)
    -t                   Use this flag to switch to post-fft test vector outputs
                         (default: False)
    --eth_spec           Use this flag to switch on Ethernet transmission of the
                         spectrometer (default: False)
    --eth_volt           Use this flag to switch on Ethernet transmission of
                         F-engine data (default: False)
    -a ACCLEN            Number of spectra to accumulate per spectrometer dump.
                         Default: get from config file (default: None)
    -f FFTSHIFT          FFT shift schedule. Default: get from configuration
                         file (default: None)
    --specdest SPECDEST  Destination IP address to which spectra should be sent.
                         Default: get from config file (default: None)


Configuration File
~~~~~~~~~~~~~~~~~~

.. code-block:: yaml

  fftshift: 0xfffa
  acclen: 300000
  # Coeffs should be a single number, or an array
  # of 4096 numbers to set one coefficient per channel.
  coeffs: 100
  # UDP port for 10GbE data
  dest_port: 10000
  spectrometer_dest: 10.11.10.173
  # Define which channels should be output
  # over 10GbE in voltage dump mode.
  voltage_output:
    start_chan: 0
    n_chans: 1024
    # Channels will be spread over the following
    # destinations so that the first n_chans // len(dests)
    # go to the first IP address, etc.
    dests:
        - 10.11.10.173
  # All relevant IP/MAC mapping should be manually
  # specified here
  arp:
    10.11.10.173: 0xaeecc7b400ff
    10.11.10.174: 0xaeecc7b400a0

..
  References:

.. [e2v] e2v EV8AQ160 datasheet (https://www.teledyne-e2v.com/content/uploads/2019/10/EV8AQ160_0846K.pdf)
.. [hmcad1511] Analog Devices HMCAD1511 datasheet (https://www.analog.com/media/en/technical-documentation/data-sheets/hmcad1511.pdf)
.. [casper_snap] See https://github.com/casper-astro/casper-hardware/blob/master/FPGA_Hosts/SNAP/README.md
.. [casper_adc5g] See https://casper.ssl.berkeley.edu/wiki/ADC1x5000-8
.. [rpi] See https://www.raspberrypi.org/products/raspberry-pi-2-model-b
.. [pfb] Price, D; Spectrometers and Polyphse Filterbanks in Radio Astronomy; 2016; https://arxiv.org/abs/1607.03579
.. [quant] Thompson, A et al.; Convenient Formulas for Quantization Efficiency; 2007; https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2006RS003585
