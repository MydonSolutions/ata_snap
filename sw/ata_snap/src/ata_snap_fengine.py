import casperfpga
import struct
import logging
import numpy as np
import time

def _ip_to_int(ip):
    """
    convert an IP string (eg '10.11.10.1') to a 32-bit binary
    string, suitable for writing to an FPGA register.
    """
    octets = list(map(int, ip.split('.')))
    ip_int = (octets[0] << 24) + (octets[1] << 16) + (octets[2] << 8) + octets[3]
    return ip_int

def silence_tftpy():
    logs = [
        'tftpy.TftpClient',
        'tftpy.TftpContext',
        'tftpy.TftpPacketFactory',
        'tftpy.TftpPacketTypes',
        'tftpy.TftpServer',
        'tftpy.TftpStates',
        ]
    for log in logs:
        l = logging.getLogger(log)
        l.setLevel(logging.CRITICAL)

class AtaSnapFengine(object):
    n_chans_f = 4096 # Number of channels generated by channelizer
    n_chans_out = 2048 # Maximum number of channels output by SNAP
    n_chans_per_block = 16 # Granularity with which we can set channels

    n_chans_per_packet = 256
    def __init__(self, host, ant_id=0, transport=casperfpga.TapcpTransport):
        self.fpga = casperfpga.CasperFpga(host, transport=transport)
        silence_tftpy()
        self.host = host
        self.logger = logging.getLogger('AtaSnapFengine')
        self.logger.setLevel(logging.DEBUG)
        self.ant_id = ant_id
        # If the board is programmed, try to get the fpg data
        #if self.is_programmed():
        #    try:
        #        self.fpga.transport.get_meta()
        #    except:
        #        self.logging.warning("Tried to get fpg meta-data from a running board and failed!")

    def is_programmed(self):
        """
        Returns True if the fpga appears to be programmed
        with a valid F-engine design. Returns False otherwise
        """
        if 'fversion' in self.fpga.listdev():
            version = self.fpga.read_uint('fversion')
            self.logger.info("FPGA F-Engine version (based on 'fversion' register) is %d" % version)
            return True
        return False

    def program(self, fpgfile, force=False, init_adc=True):
        """
        Program the SNAP with new firmware.
        Inputs:
           fpgfile (str): Name of firmware file to load
           force (bool): If True, overwrite the loaded design even if it already appears to be loaded.
           init_adc (bool): If True, initialize the ADC cards after programming.
        """
        # in an abuse of the casperfpga API, only the TapcpTransport has a "force" option
        if isinstance(self.fpga.transport, casperfpga.TapcpTransport):
            self.fpga.transport.upload_to_ram_and_program(fpgfile, force=force)
        else:
            self.fpga.upload_to_ram_and_program(fpgfile)
        self.fpga.get_system_information(fpgfile)
        if init_adc:
            self.adc_initialize()

    def adc_initialize(self):
        """
        Configure the ADC5g card for dual input 2.5Gsps operation.
        This must be called after programming a board (which occurs
        automatically if using this class's `program` method with init_adc=True.
        """
        import adc5g
        self.logger.info("Configuring ADC->FPGA interface")
        chosen_phase, glitches = adc5g.calibrate_mmcm_phase(self.fpga, 0, ['ss_adc'])
        self.logger.info("Glitches-vs-capture phase: %s" % glitches)
        self.logger.info("Chosen phase: %d" % chosen_phase)
        self.logger.info("Configuring ADCs for dual-input mode")
        adc5g.spi.set_spi_control(self.fpga, 0, adcmode=0b0100, stdby=0, dmux=1, bg=1, bdw=0b11, fs=0, test=0)

    def adc_get_samples(self):
        """
        Get a block of samples from both ADC inputs.

        Returns: x, y (numpy arrays of ADC sample values)
        """
        d, t = self.fpga.snapshots.ss_adc.read_raw(man_trig=True, man_valid=True)
        d_unpacked = np.fromstring(d['data'], dtype=np.int8)
        x = d_unpacked[0::2]
        y = d_unpacked[1::2]
        return x, y


    def sync_wait_for_pps(self):
        """
        Block until an external PPS trigger has passed.
        """
        self.logger.info('Waiting for PPS to pass')
        count_now = self.sync_get_ext_count()
        while (self.sync_get_ext_count() == count_now):
            time.sleep(0.05)

    def sync_arm(self):
        """
        Arm the sync generators for triggering on a 
        subsequent PPS.

        Returns: sync trigger time, in UNIX format
        """
        self.logger.info('Issuing sync arm')
        self.fpga.write_int('sync_arm', 0)
        self.fpga.write_int('sync_arm', 1)
        self.fpga.write_int('sync_arm', 0)
        sync_time = int(np.ceil(time.time())) + 2
        self.fpga.write_int('sync_sync_time', sync_time)
        return sync_time

    def sync_get_adc_clk_freq(self):
        """
        Infer the ADC clock period by counting FPGA clock ticks
        between PPS events.
        Returns: ADC clock rate in MHz
        """
        adc_count = 8 * self.sync_get_fpga_clk_pps_interval()
        freq_mhz = adc_count / 1.0e6
        return freq_mhz

    def sync_get_ext_count(self):
        """
        Read the number of external sync pulses which have been received since
        the board was last programmed.
        """
        return self.fpga.read_uint('sync_count')

    def sync_get_fpga_clk_pps_interval(self):
        """
        Read the number of FPGA clocks between the last two external sync pulses
        """
        return self.fpga.read_uint('sync_period')

    def _sync_set_period(self, period):
        """
        Set the period, in FPGA clock ticks, of the internal sync pulse generation
        """
        self.logger.info("Setting sync period to %d FPGA clocks" % period)
        # If there is a valid clock and PPS connected, we can turn this into a time
        clocks_per_sec = self.sync_get_fpga_clk_pps_interval()
        sync_period_ms = 1000*period / float(clocks_per_sec)
        self.logger.info("Based on the PPS input, sync period is %.2f milliseconds" % sync_period_ms)
        if period % self.n_chans_f:
            self.logger.warning("Sync period %d is not compatible with spectrum length %d" % (period, self.n_chans_f))
        if period % 6:
            self.logger.warning("Sync period %d is not compatible with voltage output reordering." % (period))
            self.logger.warning("Sync period should be a multiple of 6")
        self.fpga.write_int('timebase_sync_period', period)

    def set_accumulation_length(self, acclen):
        """
        Set the number of spectra to accumulate for the on-board
        spectrometer.
        """
        self.logger.info('Setting accumulation length to %d spectra' % acclen)
        self._sync_set_period(acclen * self.n_chans_f * 2 // 8) # *2 for real-FFT; /8 for ADC demux

    #def _assign_channel(self, in_num, out_num):
    #    """
    #    Reorder the channels such that the `out_num`th channel
    #    out of the reorder block is channel `in_num`.
    #    """
    #    self.fpga.write_int('chan_reorder_chan_remap_map', in_num, word_offset=out_num)

    #def _assign_channels(self, in_nums, out_num_start):
    #    """
    #    Reorder the channels such that the `out_num + i`th channel
    #    out of the reorder block is channel `in_num` + i.
    #    """
    #    in_nums_str = struct.pack('>L', *in_nums)
    #    self.fpga.write('chan_reorder_chan_remap_map', in_nums_str, offset=out_num_start*4)

    def fft_set_shift(self, shift):
        """
        Set the FFT shift pattern to `shift`
        """
        self.logger.info('Setting FFT shift to 0x%x' % shift)
        self.fpga.write_int('pfb_fft_shift', shift)

    def fft_of_detect(self):
        """
        Read the FFT overflow detection register. Will return True if
        an overflow has been detected in the last sync period. False otherwise.
        Increase the FFT shift schedule to avoid persistent overflows.
        """
        return bool(self.fpga.read_uint('pfb_fft_of'))

    def eq_load_coeffs(self, pol, coeffs):
        """
        Load coefficients with which to multiply data prior to 4-bit quantization.

        Inputs:
            pol (int) : selects which polarization vectors are being loaded to (0 or 1)
                        0 is the first ADC input, 1 is the second.
            coeffs (float, or np.array/list of floats):
                      The coefficients to load. If `coeffs` is a single number, this value
                      is loaded as the coefficient for all frequency channels. If `coeffs`
                      is an array or list, it should have length self.n_chans_f. Element [i]
                      of this vector is the coefficient applied to channel i.
                      Coefficients are quantized to UFix16_5 precision.
        """
        COEFF_BITS = 16 # Bits per coefficient
        COEFF_BP = 5 # binary point position

        assert pol in [0, 1]
        # If the coefficients provided are a single number
        # set all coefficients to this value
        try:
            coeff = float(coeffs)
            coeffs = [coeff for _ in range(self.n_chans_f)]
        # Otherwise force numpy array to list
        except TypeError:
            coeffs = list(coeffs)
            assert len(coeffs) == self.n_chans_f
        # Negative equalization coefficients don't make sense!
        for coeff in coeffs:
            assert coeff >= 0
        # Manipulate scaling  so that we can write an integer which
        # will be interpreted as a UFix16_5 number.
        coeffs = [min(2**COEFF_BITS - 1, int(c*COEFF_BP)) for c in coeffs] # scale up by binary point and saturate
        if COEFF_BITS == 8:
            coeffs_str = struct.pack('>%dB'%self.n_chans_f, *coeffs)
        elif COEFF_BITS == 16:
            coeffs_str = struct.pack('>%dH'%self.n_chans_f, *coeffs)
        elif COEFF_BITS == 32:
            coeffs_str = struct.pack('>%dL'%self.n_chans_f, *coeffs)
        else:
            raise TypeError("Don't know how to convert %d-bit numbers to binary" % COEFF_BITS)
        self.fpga.write('eq_pol%d_coeffs' % pol, coeffs_str)
        

    def eq_load_test_vectors(self, pol, tv):
        """
        Load test vectors.
        Inputs:
            pol (int) : selects which polarization vectors are being loaded to (0 or 1)
                        0 is the first ADC input, 1 is the second.
            tv (np.array or list or ints) : Test vectors to be loaded. `tv` should have 4096
                                            elements. tv[i] is the test value for channel i.
                                            Each value should be an 8-bit number - the most-significant
                                            4 bits are interpretted as the 4-bit, signed, real part of
                                            the data stream. The least-significant 4 bits are interpretted
                                            as the 4-bit, signed, imaginary part of the data stream.
        """
        tv = list(tv)
        assert len(tv) == self.n_chans_f
        assert pol in [0, 1]
        tv_8bit = [x%256 for x in tv]
        tv_8bit_str = struct.pack('>%dB'%self.n_chans_f, *tv_8bit)
        self.fpga.write('eqtvg_pol%d_tv' % pol, tv_8bit_str)

    def eq_test_vector_mode(self, enable):
        """
        Turn on or off the test vector mode downstream of the 4-bit
        quantizers. This mode can be used to replaces the
        FFT output in the data path with an arbitrary pattern which can
        be set with `eq_load_test_vectors`
        Inputs:
            enable (bool): True to turn on the test mode, False to turn off
        """
        if enable:
            self.logger.info("Turning ON post-EQ test-vectors")
        else:
            self.logger.info("Turning OFF post-EQ test-vectors")
        self.fpga.write_int('eqtvg_tvg_en', int(enable))

    def spec_test_vector_mode(self, enable):
        """
        Turn on or off the test vector mode in the spectrometer data path.
        This mode replaces the FFT output in the data path with an 8 bit counter.
        Inputs:
            enable (bool): True to turn on the test mode, False to turn off
        """
        if enable:
            self.logger.info("Turning ON post-EQ test-vectors")
        else:
            self.logger.info("Turning OFF post-EQ test-vectors")
        self.fpga.write_int('spec_tvg_tvg_en', int(enable))

    def spec_read(self, mode="auto"):
        assert mode in ["auto", "cross"]
        if mode == "auto":
            self.fpga.write_int("corr_vacc_ss_sel", 0)
        else:
            self.fpga.write_int("corr_vacc_ss_sel", 1)

        self.fpga.snapshots.corr_vacc_ss_ss0.arm() # This arms both RAMs
        d0, t0 = self.fpga.snapshots.corr_vacc_ss_ss0.read_raw(arm=False)
        d1, t1 = self.fpga.snapshots.corr_vacc_ss_ss1.read_raw(arm=False)
        d0i = struct.unpack(">%dl" % (d0["length"] // 4), d0["data"])
        d1i = struct.unpack(">%dl" % (d1["length"] // 4), d1["data"])
        if mode == "auto":
            xx_even = d0i[0::2]
            xx_odd  = d1i[0::2]
            yy_even = d0i[1::2]
            yy_odd  = d1i[1::2]
            xx = np.zeros(self.n_chans_f)
            yy = np.zeros(self.n_chans_f)
            for i in range(self.n_chans_f // 2):
                xx[2*i]   = xx_even[i]
                xx[2*i+1] = xx_odd[i]
                yy[2*i]   = yy_even[i]
                yy[2*i+1] = yy_odd[i]
            return xx, yy
        elif mode == "cross":
            xy_even_r = d0i[0::2]
            xy_even_i = d0i[1::2]
            xy_odd_r  = d1i[0::2]
            xy_odd_i  = d1i[1::2]
            xy = np.zeros(self.n_chans_f, dtype=np.complex)
            for i in range(self.n_chans_f // 2):
                xy[2*i]   = xy_even_r[i] + 1j*xy_even_i[i]
                xy[2*i+1] = xy_odd_r[i] + 1j*xy_odd_i[i]
            return xy

    def spec_plot(self, mode="auto"):
        from matplotlib import pyplot as plt
        assert mode in ["auto", "cross"]
        freq_range = np.linspace(0, self.sync_get_adc_clk_freq() / 2, self.n_chans_f + 1)[0:-1]
        if mode == "auto":
            self.logger.info("Grabbing auto-correlation spectra")
            x, y = self.spec_read(mode=mode)
            self.logger.info("Plotting spectra")
            plt.figure()
            plt.subplot(2,1,1)
            plt.title("XX")
            plt.semilogy(freq_range, x)
            plt.ylabel('Power [arb ref]')
            plt.xlabel('Frequency [MHz]')
            plt.subplot(2,1,2)
            plt.title("YY")
            plt.semilogy(freq_range, y)
            plt.ylabel('Power [arb ref]')
            plt.xlabel('Frequency [MHz]')
            plt.show()
        elif mode == "cross":
            self.logger.info("Grabbing auto-correlation spectrum")
            xy = self.spec_read(mode=mode)
            self.logger.info("Plotting spectra")
            plt.figure()
            plt.subplot(2,1,1)
            plt.title("abs(X*Y)")
            plt.semilogy(freq_range, np.abs(xy))
            plt.ylabel('Power [arb ref]')
            plt.xlabel('Frequency [MHz]')
            plt.subplot(2,1,2)
            plt.title("angle(X*Y)")
            plt.plot(freq_range, np.angle(xy))
            plt.ylabel('Phase [radians]')
            plt.xlabel('Frequency [MHz]')
            plt.show()

    def spec_set_destination(self, dest_ip):
        """
        Set the destination IP address for spectrometer packets.
        """
        self.logger.info('Setting spectrometer packet destination to %s' % dest_ip)
        ip_int = _ip_to_int(dest_ip)
        self.fpga.write_int("corr_dest_ip", ip_int)


    def eth_set_mode(self, mode="voltage"):
        """
        Set the 10GbE output stream to either
        "voltage" or "spectra" mode.
        """
        assert mode in ["voltage", "spectra"]
        # Disbale the ethernet output before doing anything
        self.eth_enable_output(enable=False)
        if mode == "voltage":
             self.fpga.write_int("eth_mux_use_voltage", 1)
        elif mode == "spectra":
             self.fpga.write_int("eth_mux_use_voltage", 0)

    def eth_enable_output(self, enable=True):
        """
        Enable the 10GbE output datastream. Only do this
        after appropriately setting an output configuration
        with `select_output_channels`
        """
        ENABLE_MASK =  0x00000002
        v = self.fpga.read_uint("eth_ctrl")
        v = v &~ ENABLE_MASK
        if enable:
            v = v | ENABLE_MASK
        self.fpga.write_int("eth_ctrl", v)

    def eth_reset(self):
        """
        Reset the Ethernet core. This method will clear the reset after asserting.
        Reactivate the Ethernet core with `eth_enable_output`
        """
        RST_MASK = 0x00040001 # both stats and core resets
        self.eth_enable_output(enable=False)
        v = self.fpga.read_uint("eth_ctrl")
        v = v | RST_MASK
        self.fpga.write_int("eth_ctrl", v)
        v = v &~ RST_MASK
        self.fpga.write_int("eth_ctrl", v)

    def eth_print_counters(self):
        """
        Print ethernet stats counters. A simple wrapper around casperfpgas gbes.read_counters() method.
        """
        print(self.fpga.gbes.eth_core.read_counters())

    def eth_set_dest_port(self, port):
        """
        Set the destination UDP port for output 10GbE packets to `port`
        """
        PORT_MASK = (0xffff << 2)
        v = self.fpga.read_uint("eth_ctrl")
        v = v &~ PORT_MASK
        v = v | (port << 2)
        self.fpga.write_int("eth_ctrl", v)

    def set_dest_mac(self, ip, mac):
        """
        Set the MAC address of a given IP.

        Inputs:
            ip [str]  : IP address of ARP entry. Eg. '10.0.1.123'
            mac [int] : MAC address of ARP entry. Eg. 0x020304050607
        """

    def select_output_channels(self, start_chan, n_chans, dests=['0.0.0.0']):
        """
        Select a range of channels to output.
        Inputs:
            start_chan [int]    : First channel to output
            n_chans [int]       : Number of channels to output
            dests [list of str] : List of IP address strings to which data should be sent.
                                  The first n_chans / len(dests) will be sent to dest[0], etc..

        `start_chan` should be a multiple of self.n_chans_per_block
        `n_chans` should be a multiple of self.n_chans_per_packet
        `n_chans` should be <= self.n_chans_out
        """

        ant_id = self.ant_id

        assert start_chan % self.n_chans_per_block == 0
        assert n_chans % self.n_chans_per_packet == 0
        assert n_chans <= self.n_chans_out
        assert start_chan + n_chans <= self.n_chans_f
        # Can't sent to more destinations than we have packets-per-spectrum
        n_dests = len(dests)
        assert n_dests <= n_chans // self.n_chans_per_packet 
        # Require that traffic is spread over destinations in a balanced fashion
        assert (n_chans // self.n_chans_per_packet) % n_dests == 0
        n_slots_per_dest = (n_chans // self.n_chans_per_packet) // n_dests

        self.logger.info('Number of destinations: %d' % n_dests)
        self.logger.info('Number of slots per destination: %d' % n_slots_per_dest)

        # Attempt to send these channels at regularly spaced intervals
        n_available_slots = self.n_chans_out // self.n_chans_per_packet
        n_required_slots  = n_chans // self.n_chans_per_packet
        n_spare_slots = n_available_slots - n_required_slots

        self.logger.info('Available slots: %s' % n_available_slots)
        self.logger.info('Required slots: %s' % n_required_slots)
        self.logger.info('Spare slots: %s' % n_spare_slots)
        # Number of used slots in a row which we can follow with a dummy slot
        # This will never generate more than 1 unused slot per used slot, but this
        # is fine, if not optimal to minimize traffic burstiness
        if n_spare_slots == 0:
            n_slots_req_per_spare = n_required_slots
        else:
            n_slots_req_per_spare = int(np.ceil(n_required_slots / n_spare_slots))

        self.logger.info('Number of used consecutive used slots: %s' % n_slots_req_per_spare)

        slot_chan = []
        slot_is_valid = []
        slot_dest = []
        slot_start_chan = start_chan
        n_chans_assigned = 0
        n_slots_assigned = 0
        sn = 0
        dest_slot_cnt = 0
        for slot in range(n_available_slots):
            # Every block of n_slots_req_per_spare valid blocks, insert a dummy
            if sn == n_slots_req_per_spare:
                slot_chan += [0]
                slot_is_valid += [False]
                slot_dest += ['0.0.0.0'] # firmware interprets as "don't send"
                sn = 0
                continue
            # Deal with unused slots at the end
            if n_chans_assigned >= n_chans:
                slot_chan += [0]
                slot_is_valid += [False]
                slot_dest += ['0.0.0.0'] # firmware interprets as "don't send"
                continue
            slot_chan += [slot_start_chan]
            slot_is_valid += [True]
            slot_dest += [dests[n_slots_assigned // n_slots_per_dest]]
            slot_start_chan += self.n_chans_per_packet
            n_chans_assigned += self.n_chans_per_packet
            n_slots_assigned += 1
            sn += 1

        # Now reorder channels and set output headers appropriately
        for slot in range(n_available_slots):
            sc = slot_chan[slot]
            self.logger.info("Sending slot %d to %s (start channel %d)" % (slot, slot_dest[slot], sc))
            self.fpga.write_int('packetizer_ants', self.ant_id, word_offset=slot)
            self.fpga.write_int('packetizer_ips', _ip_to_int(slot_dest[slot]), word_offset=slot)
            self.fpga.write_int('packetizer_chans', sc, word_offset=slot)
            if not slot_is_valid[slot]:
                self._assign_chans(range(self.n_chans_per_packet), slot*2*self.n_chans_per_packet)
            else:
                self._assign_chans(range(sc, sc + self.n_chans_per_packet), slot*2*self.n_chans_per_packet)

    def _assign_chans(self, channel_range, start_index):
        """
        Reorder channels such that channel_range[i] becomes index start_index+i
        Inputs:
            channel_range (list of ints) (Must be a multpile of 4 channels long, in contiguous
                                          blocks of 4 channels)
            start_index (int) (Must be a multiple of 4 channels)
        """
        assert len(channel_range) % 4 == 0
        assert start_index % 4 == 0
        self.logger.info("Reordering channels %s to start at index %d" % (channel_range, start_index))
        channel_range = [x//4 for x in channel_range[0::4]]
        channel_range_str = struct.pack('>%dH' % (len(channel_range)), *channel_range)
        start_index = start_index // 4
        # Write at offset 2*start_index, since each index is two bytes in memory
        write_offset = start_index * 2
        print(len(channel_range_str), write_offset)
        assert write_offset % 4 == 0, 'Attempted write incompatible with 32-bit word boundaries'
        self.fpga.write("chan_reorder_reorder3_map1", channel_range_str, offset=write_offset)

