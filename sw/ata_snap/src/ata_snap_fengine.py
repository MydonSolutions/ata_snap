import casperfpga
import struct
import logging

class AtaSnapFengine(object):
    n_chans_f = 4096 # Number of channels generated by channelizer
    n_chans_out = 2048 # Maximum number of channels output by SNAP
    n_chans_per_block = 16 # Granularity with which we can set channels

    n_chans_per_packet = 128
    def __init__(self, host, ant_id=None, transport=casperfpga.TapcpTransport):
        self.fpga = casperfpga.CasperFpga(host, transport=transport)
        self.host = host
        self.logger = logging.getLogger('AtaSnapFengine')
        self.ant_id = ant_id
        # If the board is programmed, try to get the fpg data
        if self.is_programmed():
            try:
                self.fpga.transport.get_meta()
            except:
                self.logging.warning("Tried to get fpg meta-data from a running board and failed!")

    def is_programmed(self):
        """
        Returns True if the fpga appears to be programmed
        with a valid F-engine design. Returns False otherwise
        """
        if 'fversion' in self.fpga.listdev():
            version = self.fpga.read_uint('fversion')
            self.logger.info("FPGA F-Engine version (based on 'fversion' register) is %d" % version)
            return True
        return False

    def program(self, fpgfile):
        """
        Program the SNAP with `fpgfile`
        """
        self.fpga.upload_to_ram_and_program(fpgfile)

    def sync_arm(self):
        self.fpga.write_int('sync_arm', 0)
        self.fpga.write_int('sync_arm', 1)
        self.fpga.write_int('sync_arm', 0)

    def sync_get_ext_count(self):
        """
        Read the number of external sync pulses which have been received since
        the board was last programmed.
        """
        return self.fpga.read_uint('sync_count')

    def sync_get_ext_period(self):
        """
        Read the number of FPGA clocks between the last two external sync pulses
        """
        return self.fpga.read_uint('sync_period')

    def sync_set_period(self, period):
        """
        Set the period, in FPGA clock ticks, of the internal sync pulse generation
        """
        self.fpga.write_int('timebase_sync_period', period)

    def _assign_channel(self, in_num, out_num):
        """
        Reorder the channels such that the `out_num`th channel
        out of the reorder block is channel `in_num`.
        """
        self.fpga.write_int('chan_reorder_chan_remap_map', in_num, word_offset=out_num)

    def _assign_channels(self, in_nums, out_num_start):
        """
        Reorder the channels such that the `out_num + i`th channel
        out of the reorder block is channel `in_num` + i.
        """
        in_nums_str = struct.pack('>L', *in_nums)
        self.fpga.write('chan_reorder_chan_remap_map', in_nums_str, offset=out_num_start*4)

    def fft_set_shift(self, shift):
        """
        Set the FFT shift pattern to `shift`
        """
        self.fpga.write_int('pfb_fft_shift', shift)

    def fft_of_detect(self):
        """
        Read the FFT overflow detection register. Will return True if
        an overflow has been detected in the last sync period. False otherwise.
        Increase the FFT shift schedule to avoid persistent overflows.
        """
        return bool(self.fpga.read_uint('pfb_fft_of'))

    def eq_load_coeffs(self, pol, coeffs):
        """
        Load coefficients with which to multiply data prior to 4-bit quantization.

        Inputs:
            pol (int) : selects which polarization vectors are being loaded to (0 or 1)
                        0 is the first ADC input, 1 is the second.
            coeffs (float, or np.array/list of floats):
                      The coefficients to load. If `coeffs` is a single number, this value
                      is loaded as the coefficient for all frequency channels. If `coeffs`
                      is an array or list, it should have length self.n_chans_f. Element [i]
                      of this vector is the coefficient applied to channel i.
                      Coefficients are quantized to UFix16_5 precision.
        """
        COEFF_BITS = 16 # Bits per coefficient
        COEFF_BP = 5 # binary point position

        assert pol in [0, 1]
        # If the coefficients provided are a single number
        # set all coefficients to this value
        try:
            coeff = float(coeffs)
            coeffs = [coeff for _ in self.n_chans_f]
        # Otherwise force numpy array to list
        except TypeError:
            coeffs = list(coeffs)
            assert len(coeffs) == self.n_chans_f
        # Negative equalization coefficients don't make sense!
        for coeff in coeffs:
            assert coeff >= 0
        # Manipulate scaling  so that we can write an integer which
        # will be interpreted as a UFix16_5 number.
        coeffs = [min(2**COEFF_BITS - 1, int(c*COEFF_BP)) for c in coeffs] # scale up by binary point and saturate
        if COEFF_BITS == 8:
            coeffs_str = struct.pack('>B', *coeffs)
        elif COEFF_BITS == 16:
            coeffs_str = struct.pack('>H', *coeffs)
        elif COEFF_BITS == 32:
            coeffs_str = struct.pack('>L', *coeffs)
        else:
            raise TypeError("Don't know how to convert %d-bit numbers to binary" % COEFF_BITS)
        self.fpga.write('eq_pol%d_coeffs' % pol, coeffs_str)
        

    def eq_load_test_vectors(self, pol, tv):
        """
        Load test vectors.
        Inputs:
            pol (int) : selects which polarization vectors are being loaded to (0 or 1)
                        0 is the first ADC input, 1 is the second.
            tv (np.array or list or ints) : Test vectors to be loaded. `tv` should have 4096
                                            elements. tv[i] is the test value for channel i.
                                            Each value should be an 8-bit number - the most-significant
                                            4 bits are interpretted as the 4-bit, signed, real part of
                                            the data stream. The least-significant 4 bits are interpretted
                                            as the 4-bit, signed, imaginary part of the data stream.
        """
        tv = list(tv)
        assert len(tv) == self.n_chans_f
        assert pol in [0, 1]
        tv_8bit = [x%256 for x in tv]
        tv_8bit_str = struct.pack('>B', *tv_8bit)
        self.fpga.write('eqtvg_pol%d_tv' % pol, tv_8bit_str)

    def eq_test_vector_mode(self, enable):
        """
        Turn on or off the test vector mode, which replaces the
        FFT output in the data path with an 8 bit counter.
        Inputs:
            enable (bool): True to turn on the test mode, False to turn off
        """
        self.fpga.write_int('eqtvg_tvg_en', int(enable))

    def eth_enable_output(self, enable=True):
        """
        Enable the 10GbE output datastream. Only do this
        after appropriately setting an output configuration
        with `select_output_channels`
        """

    def 

    def select_output_channels(self, start_chan, n_chans, dests=['0.0.0.0'], ant_id=None):
        """
        Select a range of channels to output.
        Inputs:
            start_chan [int]    : First channel to output
            n_chans [int]       : Number of channels to output
            dests [list of str] : List of IP address strings to which data should be sent.
                                  The first n_chans / len(dests) will be sent to dest[0], etc..
            ant                 : The antenna ID for this F-Engine board

        `start_chan` should be a multiple of self.n_chans_per_block
        `n_chans` should be a multiple of self.n_chans_per_packet
        `n_chans` should be <= self.n_chans_out
        """
        def ip_to_int(ip):
            """
            convert an IP string (eg '10.11.10.1') to a 32-bit binary
            string, suitable for writing to an FPGA register.
            """
            octets = ip.split('.')
            ip_int = (octet[0] << 24) + (octet[1] << 16) + (octet[2] << 8) + octet[3]
            return ip_int

        ant_id = ant_id or self.ant_id
        assert ant_id is not None

        assert start_chan % self.n_chans_per_block == 0
        assert n_chans % self.n_chans_per_packet == 0
        assert n_chans <= self.nchans_out
        assert start_chan + n_chans <= self.n_chans_f
        # Can't sent to more destinations than we have packets-per-spectrum
        n_dests = len(dests)
        assert n_dests <= n_chans // self.n_chans_per_packet 
        # Require that traffic is spread over destinations in a balanced fashion
        assert (n_chans // self.n_chans_per_packet) % n_dests == 0
        n_slots_per_dest = (n_chans // self.n_chans_per_packet) // n_dests

        # Attempt to send these channels at regularly spaced intervals
        n_available_slots = self.n_chans_out // self.n_chans_per_packet
        n_required_slots  = n_chans // self.n_chans_per_packet
        n_spare_slots = n_available_slots - n_required_slots
        # Number of used slots in a row which we can follow with a dummy slot
        # This will never generate more than 1 unused slot per used slot, but this
        # is fine, if not optimal to minimize traffic burstiness
        n_slots_req_per_spare = int(ceil(n_required_slots / n_spare_slots))

        slot_chan = []
        slot_is_valid = []
        slot_dest = []
        slot_start_chan = start_chan
        n_chans_assigned = 0
        n_slots_assigned = 0
        sn = 0
        dest_slot_cnt = 0
        for slot in range(n_available_slots):
            # Deal with unused slots at the end
            if n_chans_assigned >= n_chans:
                slot_chan += [0]
                slot_is_valid += [False]
                slot_dest += ['0.0.0.0'] # firmware interprets as "don't send"
                continue
            slot_chan += [slot_start_chan]
            slot_is_valid += [True]
            slot_dest += [dests[n_slots_assigned // n_slots_per_dest]]
            slot_start_chan += self.n_chans_per_packet
            n_chans_assigned += self.n_chans_per_packet
            n_slots_assigned += 1
            sn += 1
            # Every block of n_slots_req_per_spare valid blocks, insert a dummy
            if sn == n_slots_req_per_spare:
                slot_chan += [0]
                slot_is_valid += [False]
                sn = 0

        # Now reorder channels and set output headers appropriately
        for slot in range(n_available_slots):
            sc = slot_start_chan[slot]
            self.write_int('packetizer_ants', self.ant_id, word_offset=slot)
            self.write_int('packetizer_ips', ip_to_int(slot_dest[slot], word_offset=slot)
            self.write_int('packetizer_chans', sc, word_offset=slot)
            if not: slot_is_valid[slot]:
                self._assign_chans([0 for _ in self.n_chans_per_packet], slot*2*self.n_chans_per_packet)
            else:
                self._assign_chans(range(sc, sc + self.n_chans_per_packet), slot*2*self.n_chans_per_packet)
